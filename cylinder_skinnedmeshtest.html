<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Three.js Bones Browser</title>
		<style>
			@font-face {
				font-family: 'inconsolata';
				src: url('../files/inconsolata.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}

			body {
				margin:0;
				font-family: 'inconsolata';
				font-size: 15px;
				line-height: 18px;
				overflow: hidden;
			}

			canvas { width: 100%; height: 100% }

			#newWindow {
				display: block;
				position: absolute;
				bottom: 0.3em;
				left: 0.5em;
				color: #fff;
			}
		</style>
	</head>
	<body>

		<a id='newWindow' href='./bones-browser.html' target='_blank'>Open in New Window</a>

		<script src="three.js"></script>
		<script src='dat.gui.min.js'></script>
		<script src="OrbitControls.js"></script>

		<script>

			var gui, scene, camera, renderer, orbit, lights, mesh, bones, skeletonHelper;

			var state = {
				animateBones: false,
                download: false
			};

			function initScene() {

				gui = new dat.GUI();
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 200 );
				camera.position.z = 30;
				camera.position.y = 30;

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 1 );
				document.body.appendChild( renderer.domElement );

				orbit = new THREE.OrbitControls( camera, renderer.domElement );
				orbit.enableZoom = false;

				lights = [];
				lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
				lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );

				lights[ 0 ].position.set( 0, 200, 0 );
				lights[ 1 ].position.set( 100, 200, 100 );
				lights[ 2 ].position.set( - 100, - 200, - 100 );

				scene.add( lights[ 0 ] );
				scene.add( lights[ 1 ] );
				scene.add( lights[ 2 ] );

				window.addEventListener( 'resize', function () {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				}, false );

				initBones();
				setupDatGui();

			}

			function createGeometry( sizing ) {

				var geometry = new THREE.CylinderBufferGeometry(
					5, // radiusTop
					5, // radiusBottom
					sizing.height, // height
					8, // radiusSegments
					sizing.segmentCount * 3, // heightSegments
					true // openEnded
				);

				var position = geometry.attributes.position;

				var vertex = new THREE.Vector3();

				var skinIndices = [];
				var skinWeights = [];

				for ( var i = 0; i < position.count; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					var y = ( vertex.y + sizing.halfHeight );

					var skinIndex = Math.floor( y / sizing.segmentHeight );
					var skinWeight = ( y % sizing.segmentHeight ) / sizing.segmentHeight;

					skinIndices.push( skinIndex, skinIndex + 1, 0, 0 );
					skinWeights.push( 1 - skinWeight, skinWeight, 0, 0 );

				}

				geometry.addAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );
				geometry.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );

				return geometry;

			}

			function createBones( sizing ) {

				bones = [];

				var prevBone = new THREE.Bone();
				bones.push( prevBone );
				prevBone.position.y = - sizing.halfHeight;

				for ( var i = 0; i < sizing.segmentCount; i ++ ) {

					var bone = new THREE.Bone();
					bone.position.y = sizing.segmentHeight;
					bones.push( bone );
					prevBone.add( bone );
					prevBone = bone;

				}

				return bones;

			}

			function createMesh( geometry, bones ) {

				var material = new THREE.MeshPhongMaterial( {
					skinning: true,
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					flatShading: true
				} );

				var mesh = new THREE.SkinnedMesh( geometry,	material );
				var skeleton = new THREE.Skeleton( bones );

				mesh.add( bones[ 0 ] );

				mesh.bind( skeleton );

				skeletonHelper = new THREE.SkeletonHelper( mesh );
				skeletonHelper.material.linewidth = 2;
				scene.add( skeletonHelper );

				return mesh;

			}

			function setupDatGui() {

				var folder = gui.addFolder( "General Options" );
               
				folder.add( state, "animateBones" );
				folder.__controllers[ 0 ].name( "Animate Bones" );

				folder.add( mesh, "pose" );
				folder.__controllers[ 1 ].name( ".pose()" );
               
               folder.add( state, "download" );
				folder.__controllers[ 2 ].name( "download" );


				var bones = mesh.skeleton.bones;

				for ( var i = 0; i < bones.length; i ++ ) {

					var bone = bones[ i ];

					folder = gui.addFolder( "Bone " + i );

					folder.add( bone.position, 'x', - 10 + bone.position.x, 10 + bone.position.x );
					folder.add( bone.position, 'y', - 10 + bone.position.y, 10 + bone.position.y );
					folder.add( bone.position, 'z', - 10 + bone.position.z, 10 + bone.position.z );

					folder.add( bone.rotation, 'x', - Math.PI * 0.5, Math.PI * 0.5 );
					folder.add( bone.rotation, 'y', - Math.PI * 0.5, Math.PI * 0.5 );
					folder.add( bone.rotation, 'z', - Math.PI * 0.5, Math.PI * 0.5 );

					folder.add( bone.scale, 'x', 0, 2 );
					folder.add( bone.scale, 'y', 0, 2 );
					folder.add( bone.scale, 'z', 0, 2 );

					folder.__controllers[ 0 ].name( "position.x" );
					folder.__controllers[ 1 ].name( "position.y" );
					folder.__controllers[ 2 ].name( "position.z" );

					folder.__controllers[ 3 ].name( "rotation.x" );
					folder.__controllers[ 4 ].name( "rotation.y" );
					folder.__controllers[ 5 ].name( "rotation.z" );

					folder.__controllers[ 6 ].name( "scale.x" );
					folder.__controllers[ 7 ].name( "scale.y" );
					folder.__controllers[ 8 ].name( "scale.z" );

				}

			}

			function initBones() {

				var segmentHeight = 8;
				var segmentCount = 4;
				var height = segmentHeight * segmentCount;
				var halfHeight = height * 0.5;

				var sizing = {
					segmentHeight: segmentHeight,
					segmentCount: segmentCount,
					height: height,
					halfHeight: halfHeight
				};

				var geometry = createGeometry( sizing );
				var bones = createBones( sizing );
				mesh = createMesh( geometry, bones );

				mesh.scale.multiplyScalar( 1 );
				scene.add( mesh );

			}
           
            function download_to_obj(data, filename, type) {
                var file = new Blob([data], {type: type});
                if (window.navigator.msSaveOrOpenBlob) // IE10+
                    window.navigator.msSaveOrOpenBlob(file, filename);
                else { // Others
                    var a = document.createElement("a"),
                            url = URL.createObjectURL(file);
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(function() {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);  
                    }, 0); 
                }
            }
           
            function download() {
               console.log("init download");
               var output = "";
               var indexVertex = 0;
		       var indexVertexUvs = 0;
		       var indexNormals = 0;
               var vertices = mesh.geometry.getAttribute('position');
                   var normals = mesh.geometry.getAttribute('normal');
                   
				  var uvs = mesh.geometry.getAttribute('uv');
				  var indices = mesh.geometry.getIndex();
				  var skinIndices = mesh.geometry.getAttribute('skinIndex');
				  var weights = mesh.geometry.getAttribute('skinWeight');
//               debugger;;
               output += 'o ' + mesh.name + '\n';
               
               var nbVertex = 0;
			   var nbNormals = 0;
			   var nbVertexUvs = 0;
               var normalMatrixWorld = new THREE.Matrix3();
               var vertex = new THREE.Vector3();
               
		       var normal = new THREE.Vector3();
		       var uv = new THREE.Vector2();

              var i,
              j,
              l,
              m,
              face = [];
               for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {
                  vertex.x = vertices.getX(i);
							vertex.y = vertices.getY(i);
							vertex.z = vertices.getZ(i);
							vertex.applyMatrix4(mesh.matrixWorld);

							skinIndex = [];
							skinIndex[0] = skinIndices.getX(i);
							skinIndex[1] = skinIndices.getY(i);
							skinIndex[2] = skinIndices.getZ(i);
							skinIndex[3] = skinIndices.getW(i);

							skinWeight = [];
							skinWeight[0] = weights.getX(i);
							skinWeight[1] = weights.getY(i);
							skinWeight[2] = weights.getZ(i);
							skinWeight[3] = weights.getW(i);

							inverses = [];
							inverses[0] = mesh.skeleton.boneInverses[skinIndex[0]];
                     
							inverses[1] = mesh.skeleton.boneInverses[skinIndex[1]];
							inverses[2] = mesh.skeleton.boneInverses[skinIndex[2]];
							inverses[3] = mesh.skeleton.boneInverses[skinIndex[3]];
// debugger;;
//							skinMatrices = [];
//							skinMatrices[0] = mesh.skeleton.bones[skinIndex[0].toString()].matrixWorld;
//                  console.log(skinIndices);
//							skinMatrices[1] = mesh.skeleton.bones[skinIndex[1].toString()].matrixWorld;
//							skinMatrices[2] = mesh.skeleton.bones[skinIndex[2].toString()].matrixWorld;;
//							skinMatrices[3] = mesh.skeleton.bones[skinIndex[3].toString()].matrixWorld;
                 

							var finalVector = new THREE.Vector4();
                            for (var k = 0; k < 4; k++) {
						
						      var tempVector = new THREE.Vector4(vertex.x, vertex.y, vertex.z);
//						
//
								
//								//the inverse takes the vector into local bone space
//								//which is then transformed to the appropriate world space
//								tempVector.applyMatrix4(inverses[k]);
//                               tempVector.applyMatrix4(skinMatrices[k]);
//                               tempVector.multiplyScalar(skinWeight[k]);
								finalVector.add(tempVector);
//
							}
                           output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';
               }
               
//               for uv's
               for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {

						uv.x = uvs.getX(i);
						uv.y = uvs.getY(i);

						// transform the uv to export format
						output += 'vt ' + uv.x + ' ' + uv.y + '\n';

					}

				
           
//           for normals
              for (i = 0, l = normals.count; i < l; i++, nbNormals++) {

                           normal.x = normals.getX(i);
                           normal.y = normals.getY(i);
                           normal.z = normals.getZ(i);

                           // transfrom the normal to world space
   						normal.applyMatrix3(normalMatrixWorld);

                           // transform the normal to export format
                           output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';

               }
           
           
//         for faces
           for (i = 0, l = indices.count; i < l; i += 3) {

						for (m = 0; m < 3; m++) {

							j = indices.getX(i + m) + 1;

							face[m] = (indexVertex + j) + '/' + (uvs ? (indexVertexUvs + j) : '') + '/' + (indexNormals + j);

						}

						// transform the face to export format
						output += 'f ' + face.join(' ') + "\n";

					}

               download_to_obj(output, "output1.obj", 'text');
                  
            }
            var downloaded = false;

			function render() {

				requestAnimationFrame( render );

				if ( state.download && downloaded == false ) {
                     
					download();
                   downloaded = true;
                   
                   

				}

				renderer.render( scene, camera );

			}

			initScene();
			render();

		</script>
	</body>
</html>
